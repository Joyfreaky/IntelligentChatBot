import dash
from dash import dcc
from dash import html
from dash.dependencies import Input, Output
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from dash import dash_table
import dash_bootstrap_components as dbc

# Ignore the alerts generated by the Dash app
import logging
logger = logging.getLogger('werkzeug')
logger.setLevel(logging.ERROR)

from flask_caching import Cache

from dateutil import parser # converting offset-naive and offset-aware datetimes

from sqlalchemy import create_engine

db_file_path = '/app/data/database/alerts.db'

# Update the database file path for passive DNS data
passive_dns_db_file_path = '/app/data/database/passive_dns.db'


# Establish a connection to the SQL database
engine = create_engine(f'sqlite:///{db_file_path}', echo=False, pool_pre_ping=True)

# Establish a connection to the SQL database for passive DNS data
engine2 = create_engine(f'sqlite:///{passive_dns_db_file_path}', echo=False, pool_pre_ping=True)

# Set up the external stylesheet
external_stylesheets = [dbc.themes.CERULEAN]

# Initialize the Dash app
app = dash.Dash(__name__, external_stylesheets=external_stylesheets)

# Set the app's stylesheet
app.css.append_css({'external_url': 'https://stackpath.bootstrapcdn.com/bootswatch/4.5.2/cerulean/bootstrap.min.css'})

cache = Cache(app.server,config={
    'CACHE_TYPE': 'filesystem',
    'CACHE_DIR': '/app/data/cache/'
})

TIMEOUT = 60

@cache.memoize(timeout=TIMEOUT)
# Initial data loading function
def load_initial_data():
    # Read data from the sql database
    query = "SELECT DISTINCT NodeName, Category, NodeType, * FROM alerts GROUP BY NodeName, Category, NodeType ORDER BY DetectTime ASC LIMIT 1000"
    df_alerts = pd.read_sql_query(query, engine)

    # if the column names are repeated then keep only the first occurence of the column name and drop the rest of the columns with the same name 
    df_alerts = df_alerts.loc[:,~df_alerts.columns.duplicated()]

    # Convert the DetectTime, EventTime, WinStartTime, WinEndTime column to datetime
    df_alerts['DetectTime'] = pd.to_datetime(df_alerts['DetectTime'], format='ISO8601', utc=True)
    df_alerts['EventTime'] = pd.to_datetime(df_alerts['EventTime'], format='ISO8601', utc=True)
    df_alerts['WinStartTime'] = pd.to_datetime(df_alerts['WinStartTime'], format='ISO8601', utc=True)
    df_alerts['WinEndTime'] = pd.to_datetime(df_alerts['WinEndTime'], format='ISO8601', utc=True)
    
    return df_alerts

# Batch loading fuction
@cache.memoize(timeout=TIMEOUT)
def load_batch_data(start_index, end_index, node, category, nodetype, start_date, end_date, sort_by, filter_query):
    #df_alerts = load_initial_data()

    # Build the SQL query
    query = "SELECT * FROM alerts"
    conditions = []

    if node is not None:
        conditions.append(f"NodeName = '{node}'")

    if category is not None:
        conditions.append(f"Category = '{category}'")

    if nodetype is not None:
        conditions.append(f"NodeType = '{nodetype}'")
    
    if conditions:
        query += " WHERE " + " AND ".join(conditions)

    # fetch the data 
    df_alerts = pd.read_sql_query(query, engine)

    # Convert the DetectTime column to datetime
    df_alerts['DetectTime'] = pd.to_datetime(df_alerts['DetectTime'], format='ISO8601', utc=True)

    # Convert start_date and end_date to datetime
    
    start_date = pd.to_datetime(start_date, format='ISO8601', utc=True)
    end_date = pd.to_datetime(end_date, format='ISO8601', utc=True)  

    # Filter data based on the selected date range
    df_filtered = df_alerts[(df_alerts['DetectTime'] >= start_date) & (df_alerts['DetectTime'] <= end_date)]

    

    # Server-side processing logic for sorting and filtering 
    if sort_by:
        df_filtered = df_filtered.sort_values(
            sort_by[0]['column_id'],
            ascending=sort_by[0]['direction'] == 'asc',
            inplace=False
        )
    else: 
        # By default, sort by DetectTime in Ascending order
        df_filtered = df_filtered.sort_values(
            'DetectTime',
            ascending=True,
            inplace=False
        )

    if filter_query:
        filters = filter_query.split(' && ')
        for f in filters:
            col, op, val = f.split(' ')
            df_filtered = df_filtered.loc[df_filtered[col].astype(str).str.contains(val, case=False)]

    else:
        df_filtered = df_filtered

    

    # Calculate the index range based on paginaion
    start_index = start_index if start_index is not None else 0 
    end_index = end_index if end_index is not None else len(df_filtered)
    
    return df_filtered.iloc[start_index:end_index]

# Define the function to fetch Passive DNS data from the SQL database
@cache.memoize(timeout=TIMEOUT)
def load_passive_dns_data(selected_ip):
    
    #Build the SQL query
    
    if selected_ip is not None:
        # Show only the selected IP
        query2 = f"SELECT ip, SUM(numrecords) AS numrecords, AVG(avglenrecords) AS avglenrecords FROM passiveDNS_data WHERE ip = '{selected_ip}'"
        
    
    else:
        # Show only the top 100 IPs by default
        query2 = "SELECT ip, SUM(numrecords) AS numrecords, AVG(avglenrecords) AS avglenrecords FROM passiveDNS_data GROUP BY ip ORDER BY numrecords DESC LIMIT 100"

    
    # fetch the data
    df_passive_dns = pd.read_sql_query(query2, engine2)

    return df_passive_dns

df_alerts = load_initial_data()
df_passive_dns = load_passive_dns_data(None)

# Define layout for new chart

scatter_chart_layout = dbc.Card([
    dbc.CardHeader(html.H4("Scatter Plot - Number of Records vs. Average Length of Records", className="card-title")),
    dbc.CardBody([
        dcc.Graph(id='scatter-plot', responsive=True),
        dbc.Row([
            dbc.Col([
                dcc.Dropdown(
                    id='ip-dropdown',
                    options=[{'label': ip, 'value': ip} for ip in df_passive_dns['ip'].unique()],
                    value=None,
                    placeholder="Select IP",
                    clearable=True,
                    multi=False,
                ),
            ], width=4),
        ]),
    ]),
])

# Update the layout
app.layout = html.Div([
    html.H1("Cybersecurity Threat Intelligence Dashboard", style={'textAlign': 'center', 'color': '#1f77b4', 'margin-bottom': '30px'}),

    # Row 1: Dropdowns and Date Picker
    dbc.Row([
        dbc.Col([
            dbc.Card([
                dbc.CardHeader(html.H4("Filters", className="card-title")),
                dbc.CardBody([
                    dcc.Dropdown(
                        id='node-dropdown',
                        options=[{'label': i, 'value': i} for i in df_alerts['NodeName'].unique()],
                        value='cz.cesnet.hugo.haas_dionaea',
                        placeholder="Select the End Node",
                        clearable=True,
                        multi=False,
                    ),
                    dcc.Dropdown(
                        id='category-dropdown',
                        options=[{'label': i, 'value': i} for i in df_alerts['Category'].unique()],
                        value='Recon.Scanning',
                        placeholder="Select the Attack Category",
                        clearable=True,
                        multi=False,
                    ),
                    dcc.Dropdown(
                        id='node-type-dropdown',
                        options=[{'label': i, 'value': i} for i in df_alerts['NodeType'].unique()],
                        value='Connection, Protocol, Honeypot',
                        placeholder="Select the Node Type",
                        clearable=True,
                        multi=False,
                    ),
                    dcc.DatePickerRange(
                        id='date-picker-range',
                        start_date=df_alerts['DetectTime'].min(),
                        end_date=df_alerts['DetectTime'].max(),
                        display_format='YYYY-MM-DD',
                    ),
                ]),
            ]),
        ], width=12),
    ]),

    # Row 2: Graphs Side by Side
    dbc.Row([
        dbc.Col([
            dbc.Card([
                dbc.CardHeader(html.H4("Time Series Graph", className="card-title")),
                dbc.CardBody([
                    dcc.Graph(id='time-series-graph', responsive=True),
                ]),
            ]),
        ], width=6),
        dbc.Col([
            dbc.Card([
                dbc.CardHeader(html.H4("Category Bar Chart", className="card-title")),
                dbc.CardBody([
                    dcc.Graph(id='category-bar-chart', responsive=True),
                ]),
            ]),
        ], width=6),
    ], className="mb-4"),

    # Row 3: Table
    dbc.Row([
        dbc.Col([
            dbc.Card([
                dbc.CardHeader(html.H4("Alert Table", className="card-title")),
                dbc.CardBody([
                    dash_table.DataTable(
                        id='alert-table',
                        columns=[{"name": i, "id": i} for i in df_alerts.columns],
                        page_size=10,
                        style_cell={'textAlign': 'left'},
                        style_header={
                            'backgroundColor': '#f2f2f2',
                            'fontWeight': 'bold'
                        },
                        filter_action="native",
                        sort_action="native",
                        page_action="native",
                        virtualization=True,
                        page_current=0,
                        style_table={'height': '450px', 'overflowY': 'auto'},
                    ),
                ]),
            ]),
        ], width=12),
    ]),
    #Row 4: New Scatter Plot Chart
    dbc.Row([
        dbc.Col([
            scatter_chart_layout,
        ], width=12),
    ], className="mb-4"),

], style={'maxWidth': '1200px', 'margin': 'auto'})


# Define the callback to update the time series graph
@app.callback(
    Output('time-series-graph', 'figure'),
    [Input('node-dropdown', 'value'),
     Input('category-dropdown', 'value'),
     Input('node-type-dropdown', 'value'),
     Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date')]
)
def update_time_series(node, category, nodetype, start_date, end_date):
    # Filter data based on the selected Node, category, type, and date range
    df_filtered = load_batch_data(None, None, node, category, nodetype, start_date, end_date, None, None)

    # Group and aggregate data
    df_grouped = df_filtered.groupby(['DetectTime', 'Category']).agg({
        'ConnCount': 'sum',
        'FlowCount': 'sum',
        'SourceIP': pd.Series.nunique,  # Count unique source IPs
        'TargetIP': pd.Series.nunique,  # Count unique destination IPs
    }).reset_index()

    # Add Total_attempts column as the sum of ConnCount and FlowCount
    df_grouped = df_grouped.assign(Total_attempts=df_grouped['ConnCount'] + df_grouped['FlowCount'])

    # Plot the area chart
    figure = px.area(df_grouped, x='DetectTime', y='Total_attempts', color='Category',
                     title='Cybersecurity Alerts Over Time by Category',
                     labels={'Total_attempts': 'Total Alerts', 'DetectTime': 'Time'})

    # Improve data format on x-axis
    figure.update_xaxes(
        tickformat='%Y-%m-%d %H:%M:%S',
        tickangle=45,
        rangeslider_visible=True,
        title_text='Time (UTC)'  # Updated x-axis label
    )

    # Improve tooltip information
    figure.update_traces(
        hovertemplate=(
            '<b>%{y} Alerts</b><br>%{x}' +
            '<br>Category: %{marker.color}' +
            '<br>Total FlowCount: %{customdata[0]}' +
            '<br>Total ConnCount: %{customdata[1]}'
            '<br>Unique Source IPs: %{customdata[2]}' +
            '<br>Unique Target IPs: %{customdata[3]}' +
            '<extra></extra>'
        ),
        customdata=np.array([df_grouped['FlowCount'], df_grouped['ConnCount'], df_grouped['SourceIP'], df_grouped['TargetIP']]).T,
    )

    # Ensure the legend does not overlap with the graph
    figure.update_layout(legend=dict(
        yanchor="top",
        y=0.99,
        xanchor="right",
        x=0.99
    ))

    return figure




# Define the callback to update the bar chart
@app.callback(
    Output('category-bar-chart', 'figure'),
    [Input('node-dropdown', 'value'),
     Input('category-dropdown', 'value'),
     Input('node-type-dropdown', 'value'),
     Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date')]
)
def update_bar_chart(node, category, nodetype, start_date, end_date):
    # Filter data based on the selected Node, category, type, and date range
    df_filtered = load_batch_data(None, None, node, category, nodetype, start_date, end_date, None, None)

    # Count the occurrences of each attack category
    category_counts = df_filtered['Category'].value_counts().reset_index()
    category_counts.columns = ['Category', 'Count']

    # Calculate the percentage distribution
    total_alerts = category_counts['Count'].sum()
    category_counts['Percentage'] = category_counts['Count'] / total_alerts * 100

    # Sort the categories by count in descending order
    category_counts = category_counts.sort_values('Count', ascending=False)

    # Plot the bar chart
    figure = px.bar(category_counts,
                    x='Category',
                    y=['Count', 'Percentage'],
                    text='Count',
                    color='Category',
                    labels={'Count': 'Number of Alerts', 'Percentage': 'Percentage'},
                    title='Distribution of Attack Categories',
                    height=500  # Adjust the height as needed
                    )

    # update text labels for clarity
    figure.update_traces(texttemplate='%{text}', textposition='outside')

    # Rotate x-axis labels if needed and adjust the font size
    figure.update_xaxes(tickangle=45, tickfont=dict(size=10))

    # Ensure the bar chart does not overlap with the secondary y-axis labels
    figure.update_layout(margin=dict(l=50, r=150, t=50, b=100))

    # Add a line for the total number of alerts
    total_alert_trace = go.Scatter(
        x=category_counts['Category'],
        y=[total_alerts] * len(category_counts),
        mode='lines+markers',
        name='Total Alerts',
        line=dict(color='black', width=2, dash='dash')
    )

    figure.add_trace(total_alert_trace)

    # Add labels and title to secondary y-axis
    figure.update_layout(
        yaxis2=dict(
            title='Percentage',
            overlaying='y',
            side='right',
            showgrid=False,
        ),
        yaxis=dict(title='Number of Alerts'),
        legend=dict(
            orientation='h',  # horizontal legend
            yanchor='bottom',
            y=1.02,
            xanchor='right',
            x=1
        )
    )

    return figure


# Define the callback to update the table
@app.callback(
    Output('alert-table', 'data'),
    [Input('node-dropdown', 'value'),
     Input('category-dropdown', 'value'),
     Input('node-type-dropdown', 'value'),
     Input('date-picker-range', 'start_date'),
     Input('date-picker-range', 'end_date'),
     Input('alert-table', "page_current"), # Add page_current as an input
     Input('alert-table', "page_size"), # Add page_size as an input
     Input('alert-table', 'sort_by'), # Add sort_by as an input
     Input('alert-table', 'filter_query')] # Add filter_query as an input
)
def update_table(node, category, nodetype, start_date, end_date, page_current, page_size, sort_by, filter_query):
    
    # Load batch data for the table 
    df_filtered = load_batch_data(page_current * page_size, (page_current + 1) * page_size, node, category, nodetype, start_date, end_date, sort_by, filter_query)

    return df_filtered.to_dict('records')

# Define the callback to update the scatter plot
@app.callback(
    Output('scatter-plot', 'figure'),
    [Input('ip-dropdown', 'value')]
)
def update_scatter_plot(selected_ip):
    # fetch Passive DNS data
    df_passive_dns = load_passive_dns_data(selected_ip)
    

    
    # Plot the scatter plot
    figure = px.scatter(df_passive_dns, x='numrecords', y='avglenrecords', color='ip',
                        title='Scatter Plot - Number of Records vs. Average Length of Records',
                        labels={'numrecords': 'Number of Records', 'avglenrecords': 'Average Length of Records'})

    # Improve tooltip information
    figure.update_traces(
        hovertemplate=(
            '<b>IP:</b> %{marker.color}' +
            '<br>Number of Records: %{x}' +
            '<br>Average Length of Records: %{y:.2f}' +
            '<extra></extra>'
        ),
    )

    return figure


# Run the app
if __name__ == '__main__':
    app.run_server(debug=True)